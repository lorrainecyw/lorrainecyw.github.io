(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{756:function(t,a,s){"use strict";s.r(a);var n=s(11),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("在 Java 中，实现并发程序的主要手段就是多线程")]),t._v(" "),s("h2",{attrs:{id:"通用的线程生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通用的线程生命周期"}},[t._v("#")]),t._v(" 通用的线程生命周期")]),t._v(" "),s("p",[t._v("通用的线程声明周期可以用“五态模型”来描述，五种状态分别是：初始状态（创建）、可运行状态（就绪）、运行状态、休眠状态、终止状态")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("初始状态")]),t._v("：线程已经被创建，但是还不允许分配 CPU 执行。这里所谓的被创建，指的是在编程语言层面被创建，在操作系统层面线程还没有创建")]),t._v(" "),s("li",[s("code",[t._v("可运行状态")]),t._v("：可以分配 CPU 给线程来执行了。这个状态下，真正的操作系统线程已经创建好了")]),t._v(" "),s("li",[s("code",[t._v("运行状态")]),t._v("：当有空闲的 CPU 时，操作系统将 CPU 分配给一个处于可运行状态的线程，线程得以运行")]),t._v(" "),s("li",[s("code",[t._v("休眠状态")]),t._v("：当处于运行状态的线程调用了阻塞式 API 或者等待某个条件变量（ I / O 设备等），就会转换到休眠状态，并且释放 CPU 使用权。等到等待的事件出现了，才会重新回到可运行状态")]),t._v(" "),s("li",[s("code",[t._v("终止状态")]),t._v("：线程正常执行完或者抛出异常就会进入终止状态，意味着生命周期的结束")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/jpeg/22396700/1659801322444-9f8f3ab7-30e7-43e5-aa98-71f265003a7a.jpeg",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"java-中线程的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-中线程的生命周期"}},[t._v("#")]),t._v(" Java 中线程的生命周期")]),t._v(" "),s("h3",{attrs:{id:"生命周期包含的状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期包含的状态"}},[t._v("#")]),t._v(" 生命周期包含的状态")]),t._v(" "),s("p",[t._v("Java 中线程共有六种状态，分别为：")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("NEW")]),t._v("：初始化状态")]),t._v(" "),s("li",[s("code",[t._v("RUNNABLE")]),t._v("：可运行 / 运行状态（包含了这两种状态）")]),t._v(" "),s("li",[s("code",[t._v("WAITING")]),t._v("：等待状态")]),t._v(" "),s("li",[s("code",[t._v("TIMED_WAITING")]),t._v("：有时限等待状态（等待达到了一定时间就会转变为"),s("code",[t._v("RUNNABLE")]),t._v("）")]),t._v(" "),s("li",[s("code",[t._v("BLOCKED")]),t._v("：阻塞状态")]),t._v(" "),s("li",[s("code",[t._v("TERMINATED")]),t._v("：终止状态")])]),t._v(" "),s("p",[t._v("注意点：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("WAITING")]),t._v("、"),s("code",[t._v("TIMED_WAITING")]),t._v("、"),s("code",[t._v("BLOCKED")]),t._v("都属于前面提到的睡眠状态，也就是说，只要 Java 线程处于这三种状态之一，就没有对 CPU 的使用权")]),t._v(" "),s("li",[t._v("Java 语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而 JVM 把线程调度交给操作系统处理了，所以 JVM 层面不关心这两个状态，在JVM 看来，等待CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态")])]),t._v(" "),s("h3",{attrs:{id:"状态转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#状态转换"}},[t._v("#")]),t._v(" 状态转换")]),t._v(" "),s("h4",{attrs:{id:"new-runnable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-runnable"}},[t._v("#")]),t._v(" NEW ==> RUNNABLE")]),t._v(" "),s("p",[t._v("Java 中刚创建好的线程就是"),s("code",[t._v("NEW")]),t._v("状态，创建线程有 4 种方法：继承 Thread 类，实现 Runnable 接口，实现 Callable 接口，通过线程池创建。下面用代码演示最常用的两种：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** \n*\t1. 继承Thread，重写run方法\n*/")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyThread")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//线程需要执行的代码")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//创建线程对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyThread")]),t._v(" myThread "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** \n*\t2. 实现Runnable接口，重写run方法\n*/")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runner")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runnable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//线程需要执行的代码")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//创建线程对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runner")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br")])]),s("p",[t._v("从"),s("code",[t._v("NEW")]),t._v("状态转换到"),s("code",[t._v("RUNNABLE")]),t._v("状态，只需要调用线程对象的"),s("code",[t._v("start()")]),t._v("就好了，例如"),s("code",[t._v("myThread.start();")])]),t._v(" "),s("h4",{attrs:{id:"runnable-blocked"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#runnable-blocked"}},[t._v("#")]),t._v(" RUNNABLE <==> BLOCKED")]),t._v(" "),s("p",[t._v("只有一种情况会使得线程从"),s("code",[t._v("RUNNABLE")]),t._v("转换到"),s("code",[t._v("BLOCKED")]),t._v("，那就是线程等待"),s("code",[t._v("synchronized")]),t._v("的隐式锁的时候。"),s("code",[t._v("synchronized")]),t._v("修饰的方法和代码块在同一时刻只能有一个线程访问，那么没有获得锁的线程就会阻塞等待，从"),s("code",[t._v("RUNNABLE")]),t._v("转换到"),s("code",[t._v("BLOCKED")]),t._v("，等到获得隐式锁之后又会从"),s("code",[t._v("BLOKED")]),t._v("转换到"),s("code",[t._v("RUNNABLE")]),t._v("\n注意：如果调用阻塞式 API，在操作系统层面，会转换到休眠状态，但是在 JVM 层面，不会发生状态的转换，所以我们平时说的调用阻塞式 API，线程会阻塞等待，指的是操作系统层面线程的状态")]),t._v(" "),s("h4",{attrs:{id:"runnable-waiting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#runnable-waiting"}},[t._v("#")]),t._v(" RUNNABLE <==> WAITING")]),t._v(" "),s("p",[t._v("总的来说，有 3 种场景会触发这种转换")]),t._v(" "),s("ol",[s("li",[t._v("调用"),s("code",[t._v("wait()")]),t._v("：获得了"),s("code",[t._v("synchronized")]),t._v("隐式锁的线程调用"),s("code",[t._v("wait()")]),t._v("，释放锁，状态发生转换")]),t._v(" "),s("li",[t._v("调用"),s("code",[t._v("join()")]),t._v("：当调用了"),s("code",[t._v("thread1.join()")]),t._v("，当前线程就会从"),s("code",[t._v("RUNNABLE")]),t._v("转换到"),s("code",[t._v("WAITING")]),t._v("，直到"),s("code",[t._v("thread1")]),t._v("执行完后，当前线程才会从"),s("code",[t._v("WAITING")]),t._v("转换到"),s("code",[t._v("RUNNABLE")]),t._v("，继续执行")]),t._v(" "),s("li",[t._v("调用"),s("code",[t._v("LockSupport.park()")]),t._v("：Java 并发包的锁都是基于"),s("code",[t._v("LockSupport")]),t._v("实现的，调用"),s("code",[t._v("LockSupport.park()")]),t._v("，当前线程会阻塞，转换到"),s("code",[t._v("WAITING")]),t._v("状态；调用"),s("code",[t._v("LockSupport.unpark(Thread thread)")]),t._v("，会唤醒目标线程，转换回"),s("code",[t._v("RUNNABLE")]),t._v("状态")])]),t._v(" "),s("h4",{attrs:{id:"runnable-timed-waiting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#runnable-timed-waiting"}},[t._v("#")]),t._v(" RUNNABLE <==> TIMED_WAITING")]),t._v(" "),s("p",[t._v("有 5 种场景会触发这种转换（调用之后，状态：RUNNABLE => TIMED_WAITING，时间到了就会转回来）")]),t._v(" "),s("ol",[s("li",[t._v("调用带超时参数的"),s("code",[t._v("Thread.sleep(long millis)")])]),t._v(" "),s("li",[t._v("调用带超时参数的"),s("code",[t._v("Object.wait(long timeout)")]),t._v("（获得"),s("code",[t._v("synchronized")]),t._v("隐式锁后才能调用）")]),t._v(" "),s("li",[t._v("调用带超时参数的"),s("code",[t._v("Thread.join(long millis)")])]),t._v(" "),s("li",[t._v("调用带超时参数的"),s("code",[t._v("LockSupport.parkNanos(Object blocker, long deadline)")])]),t._v(" "),s("li",[t._v("调用带超时参数的"),s("code",[t._v("LockSupport.parkUntil(long deadline)")])])]),t._v(" "),s("h4",{attrs:{id:"runnable-terminated"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#runnable-terminated"}},[t._v("#")]),t._v(" RUNNABLE ==> TERMINATED")]),t._v(" "),s("ol",[s("li",[t._v("正常执行完"),s("code",[t._v("run()")]),t._v("后")]),t._v(" "),s("li",[t._v("抛出异常后")]),t._v(" "),s("li",[t._v("调用"),s("code",[t._v("stop()")]),t._v("（已被标记为"),s("code",[t._v("@Deprecated")]),t._v("，不建议使用）")]),t._v(" "),s("li",[t._v("调用"),s("code",[t._v("interrupt()")])])]),t._v(" "),s("h5",{attrs:{id:"为什么不建议使用stop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不建议使用stop"}},[t._v("#")]),t._v(" 为什么不建议使用"),s("code",[t._v("stop()")])]),t._v(" "),s("p",[t._v("调用"),s("code",[t._v("stop()")]),t._v("后，会不给线程喘息的机会，直接杀死线程，如果线程持有"),s("code",[t._v("ReentrantLock")]),t._v("等锁，被"),s("code",[t._v("stop()")]),t._v("的线程并不会自动调用"),s("code",[t._v("unlock()")]),t._v("方法来释放这个锁，那么就导致其他线程也无法获得这个锁，实在是太危险了（如果持有的是"),s("code",[t._v("synchronized")]),t._v("锁是会释放的，JVM 会释放）。类似的还有"),s("code",[t._v("suspend()")]),t._v("和"),s("code",[t._v("resume()")]),t._v("，同样不建议使用")]),t._v(" "),s("h5",{attrs:{id:"调用interrupt"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用interrupt"}},[t._v("#")]),t._v(" 调用"),s("code",[t._v("interrupt()")])]),t._v(" "),s("p",[s("code",[t._v("interrupt()")]),t._v("仅仅是通知线程，线程有机会执行后续的一些操作，也可以无视这个通知\n而收到通知的方式有两种，一种是异常，一种是主动监测")]),t._v(" "),s("ol",[s("li",[t._v("异常\n"),s("ol",[s("li",[t._v("当线程处于"),s("code",[t._v("WAITING")]),t._v("或者"),s("code",[t._v("TIMED_WAITING")]),t._v("状态的时候，如果调用了"),s("code",[t._v("interrupt()")]),t._v("，线程就会转换到"),s("code",[t._v("RUNNABLE")]),t._v("状态，并且触发"),s("code",[t._v("InterruptedException")]),t._v("异常（这个异常的触发条件：其他线程调用了这个线程的"),s("code",[t._v("interrupt()")]),t._v("）")]),t._v(" "),s("li",[t._v("当线程处于"),s("code",[t._v("RUNNABLE")]),t._v("状态时，并且阻塞在"),s("code",[t._v("java.nio.channels.InterruptibleChannel")]),t._v("上时，如果其他线程调用线程 A 的"),s("code",[t._v("interrupt()")]),t._v("，线程 A 会触发"),s("code",[t._v("java.nio.channels.ClosedByInterruptException")]),t._v("这个异常；而阻塞在"),s("code",[t._v("java.nio.channels.Selector")]),t._v("上时，如果其他线程调用线程 A 的 "),s("code",[t._v("interrupt()")]),t._v("，线程 A 的"),s("code",[t._v("java.nio.channels.Selector")]),t._v("会立即返回")])])]),t._v(" "),s("li",[t._v("主动监测：当线程处于"),s("code",[t._v("RUNNABLE")]),t._v("状态时，如果其他线程调用了当前线程的"),s("code",[t._v("interrupt()")]),t._v("可以通过"),s("code",[t._v("isInterrupted()")]),t._v("检测是不是自己被中断了")])]),t._v(" "),s("p",[t._v("注意：抛出异常后，会自动清除当前线程的中断标识")]),t._v(" "),s("h2",{attrs:{id:"课后思考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#课后思考"}},[t._v("#")]),t._v(" 课后思考")]),t._v(" "),s("p",[t._v("下面代码的本意是当前线程被中断之后，退出"),s("code",[t._v("while(true)")]),t._v("，你觉得这段代码是否正确呢 ？")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" th "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("th"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isInterrupted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 省略业务代码无数")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InterruptedException")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\te"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("printStackTrace")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("p",[s("strong",[t._v("分析如下")])]),t._v(" "),s("ol",[s("li",[t._v("结果：可能会陷入无限循环")]),t._v(" "),s("li",[t._v("原因：线程在执行"),s("code",[t._v("Thread.sleep(100)")]),t._v("的期间的状态为"),s("code",[t._v("TIMED_WAITING")]),t._v("，如果在被打断了，就会抛出"),s("code",[t._v("InterruptedException")]),t._v("异常，抛出异常后，会自动清除掉中断标识，这样子"),s("code",[t._v("th.isInterrupted()")]),t._v("得到的结果永远是"),s("code",[t._v("false")]),t._v("，没有办法执行"),s("code",[t._v("break")]),t._v("出循环这一步")]),t._v(" "),s("li",[t._v("解决：可以在"),s("code",[t._v("catch")]),t._v("到异常的代码块中重置一下中断标识（具体做法："),s("code",[t._v("th.interrupt();")]),t._v("），这样"),s("code",[t._v("th.isInterrupted()")]),t._v("就能够得到"),s("code",[t._v("true")]),t._v("的结果并执行"),s("code",[t._v("break")]),t._v("；也可以再捕获到异常后直接在"),s("code",[t._v("catch")]),t._v("里面执行"),s("code",[t._v("break")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);