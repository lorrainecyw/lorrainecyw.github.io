(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{759:function(t,e,s){"use strict";s.r(e);var a=s(11),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("并发编程领域有两大核心问题：互斥和并发。Java SDK 并发包通过 Lock 和 Condition 两大接口来实现管程，Lock 用于解决互斥问题，让同一时刻只有一个线程能访问，Condition 用于解决同步问题")]),t._v(" "),s("h2",{attrs:{id:"再造管程的理由-为什么要编写-lock"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#再造管程的理由-为什么要编写-lock"}},[t._v("#")]),t._v(" 再造管程的理由（为什么要编写 Lock）")]),t._v(" "),s("p",[t._v("Java 语言本身提供的"),s("code",[t._v("synchronized")]),t._v("就是管程的一种实现，为什么要再编写 Lock 接口 ？可能是性能原因吗 ？不是的。虽然在"),s("code",[t._v("JDK 1.5及之前")]),t._v("，"),s("code",[t._v("synchronized")]),t._v("性能不如 SDK 中的 Lock，但是在"),s("code",[t._v("JDK 1.6")]),t._v("的时候对"),s("code",[t._v("synchronized")]),t._v("做了很多优化，性能已经追上来了，所以不是性能的原因\n"),s("code",[t._v("synchronized")]),t._v("有一个弊端，那就是在申请锁的时候，如果获取不到，线程就直接进入阻塞状态了，并且在获得锁之前无法被中断（获取锁后会响应中断），这样线程什么也干不了，自然也无法释放自己已经获取到的其他锁资源。如果造成了死锁，那么“不可剥夺”条件就无法被打破\n而 Lock 接口创建了 3 个方法来解决这个问题，让线程可以自动释放自己获得的资源，来破坏“不可剥夺”条件")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("lockInterruptibly()")]),t._v("："),s("strong",[t._v("支持响应中断")]),t._v("。让处于阻塞状态的线程可以响应中断信号，这样线程就能够被唤醒，就有机会释放自己持有的其他锁")]),t._v(" "),s("li",[s("code",[t._v("tryLock(long Time, TimeUnit unit)")]),t._v("："),s("strong",[t._v("支持超时")]),t._v("。尝试获取锁，在一定的时间里如果没有获得锁，那么线程不会进入阻塞状态，而是返回一个错误，这样线程就有机会释放自己持有的其他锁")]),t._v(" "),s("li",[s("code",[t._v("tryLock()")]),t._v("："),s("strong",[t._v("非阻塞式获取锁")]),t._v("。尝试获取锁，如果没有获取到锁，直接返回 false，不阻塞，这样就有机会释放自己持有的其他锁")])]),t._v(" "),s("h2",{attrs:{id:"如何保证可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何保证可见性"}},[t._v("#")]),t._v(" 如何保证可见性")]),t._v(" "),s("p",[t._v("第 2 讲中讲述了可见性是通过"),s("code",[t._v("Happens-Before")]),t._v("规则来保证的，"),s("code",[t._v("synchronized")]),t._v("能保证可见性也是因为"),s("code",[t._v("Happens-Before")]),t._v("中管程锁的规则，那么"),s("code",[t._v("Lock")]),t._v("是如何保证的呢 ？")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[t._v("class X {\n\t private final "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Lock")]),t._v(" rtl "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new ReentrantLock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" void addOne"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" {\n\t\t "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取锁")]),t._v("\n\t\t rtl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("lock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\t\t try {\n\t\t\t "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("value")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t } finally {\n\t\t\t "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 保证锁能释放")]),t._v("\n\t\t\t rtl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t }\n\t }\n}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br")])]),s("p",[t._v("如果线程 A 执行了"),s("code",[t._v("addOne()")]),t._v("，那么"),s("code",[t._v("value += 1")]),t._v("后 value 的值对后来的线程 B 可见吗 ？\nLock 保证可见性是利用了"),s("code",[t._v("Happens-Before")]),t._v("规则中与"),s("code",[t._v("volatile")]),t._v("有关的规则（对"),s("code",[t._v("volatile")]),t._v("变量的写操作"),s("code",[t._v("Happens-Before")]),t._v("对于"),s("code",[t._v("volatile")]),t._v("变量的读操作）。"),s("code",[t._v("ReentrantLock")]),t._v("内部持有一个"),s("code",[t._v("volatile")]),t._v("的成员变量"),s("code",[t._v("state")]),t._v("，加锁"),s("code",[t._v("lock()")]),t._v("时将"),s("code",[t._v("state")]),t._v("加一，解锁"),s("code",[t._v("unlock()")]),t._v("时将"),s("code",[t._v("state")]),t._v("减一，也就是说在加锁和解锁的时候都会读写"),s("code",[t._v("state")]),t._v("的值。根据相关的"),s("code",[t._v("Happens-Before")]),t._v("规则推断：")]),t._v(" "),s("ol",[s("li",[t._v("顺序性规则：对于线程 A，"),s("code",[t._v("value += 1")]),t._v("的操作"),s("code",[t._v("Happens-Before")]),t._v("于解锁"),s("code",[t._v("unlock()")])]),t._v(" "),s("li",[s("code",[t._v("volatile")]),t._v("变量的规则：线程 A 解锁"),s("code",[t._v("unlock()")]),t._v("中对"),s("code",[t._v("state")]),t._v("的写"),s("code",[t._v("Happens-Before")]),t._v("于线程 B 加锁"),s("code",[t._v("lock()")]),t._v("中对"),s("code",[t._v("state")]),t._v("的读，简而言之，线程 A 的"),s("code",[t._v("unlock()")]),t._v("操作"),s("code",[t._v("Happens-Before")]),t._v("于线程 B 的"),s("code",[t._v("lock()")]),t._v("操作")]),t._v(" "),s("li",[t._v("传递性规则：线程 A 的"),s("code",[t._v("value += 1")]),t._v("操作"),s("code",[t._v("Happens-Before")]),t._v("于线程 B 的"),s("code",[t._v("lock()")]),t._v("操作")])]),t._v(" "),s("p",[t._v("从上面的推断，可以看出"),s("code",[t._v("value += 1")]),t._v("后 value 的值对后来的线程 B 可见吗")]),t._v(" "),s("h2",{attrs:{id:"可重入锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁"}},[t._v("#")]),t._v(" 可重入锁")]),t._v(" "),s("p",[s("code",[t._v("ReentrantLock")]),t._v("和"),s("code",[t._v("synchronized")]),t._v("都是可重入锁。"),s("code",[t._v("Reentrant")]),t._v("本身翻译过来就是“可重入”的意思。可重入锁：获得锁的线程可以重复获取同一把锁，获取多少次就要释放多少次。可重入锁在重复获取同一把锁的过程中能够继续执行，而不可重入锁如果重复获取，线程会进入阻塞状态\n除了可重入锁外，还有可重入函数。可重入函数：多个线程可以同时调用该函数，并且都获得正确的结果，同时在一个线程内支持线程切换，并且依旧保证结果正确。也就是说，可重入函数是线程安全的")]),t._v(" "),s("h2",{attrs:{id:"公平锁与非公平锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#公平锁与非公平锁"}},[t._v("#")]),t._v(" 公平锁与非公平锁")]),t._v(" "),s("p",[s("code",[t._v("ReentrantLock")]),t._v("有两个构造函数，一个是无参构造函数，默认创建非公平锁，另一个需要传入 fair 参数，根据 fair 参数来判断是否创建公平锁。公平锁：根据线程的等待时间来唤醒线程，哪个线程等待的时间长就唤醒哪个线程。非公平锁：随机唤醒线程。"),s("code",[t._v("synchronized")]),t._v("采用的就是非公平锁\n非公平锁的性能由于公平锁。但如果锁的持有时间较长或者请求锁的平均时间间隔较长，还是采用公平锁较好，以免一些等待时间长的线程一直无法获得锁")]),t._v(" "),s("h2",{attrs:{id:"用锁的最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用锁的最佳实践"}},[t._v("#")]),t._v(" 用锁的最佳实践")]),t._v(" "),s("p",[t._v("出自并发大师 Doug Lea《Java 并发编程：设计原则与模式》一书")]),t._v(" "),s("ol",[s("li",[t._v("永远只在更新对象的成员变量时加锁")]),t._v(" "),s("li",[t._v("永远只在访问可变的成员变量时加锁")]),t._v(" "),s("li",[t._v("永远不在调用其他对象的方法时加锁")])]),t._v(" "),s("p",[s("strong",[t._v("为什么要遵守第 3 条 ？")]),t._v("\n因为调用其他对象的方法，实在是太不安全了，也许“其他”方法里面有线程"),s("code",[t._v("sleep()")]),t._v("的调用，也可能会有奇慢无比的 I / O 操作，这些都会严重影响性能。更可怕的是，“其他”类的方法可能也会加锁，然后双重加锁就可能导致死锁")])])}),[],!1,null,null,null);e.default=n.exports}}]);