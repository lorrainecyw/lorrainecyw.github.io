(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{748:function(t,s,n){"use strict";n.r(s);var a=n(11),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("并发编程的三大特征：")]),t._v(" "),n("ul",[n("li",[t._v("可见性：当一个线程修改了某个变量的值，其他线程能立刻看到修改后的新值")]),t._v(" "),n("li",[t._v("原子性：要么所有的操作都得到执行并且不被中断，要么全部不执行")]),t._v(" "),n("li",[t._v("有序性：代码执行的先后顺序和编写的先后顺序一样")])]),t._v(" "),n("h2",{attrs:{id:"源头之一-缓存导致的可见性问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#源头之一-缓存导致的可见性问题"}},[t._v("#")]),t._v(" 源头之一：缓存导致的可见性问题")]),t._v(" "),n("ol",[n("li",[t._v("在单核时代，所有的线程都是在一颗 CPU 上执行，操作的是同一个 CPU 的缓存，所以当一个线程修改了缓存中某个变量的值，其他线程就能够立刻看到修改后的新值。所以说，一个线程对缓存的写，对其他线程一定是可见的")]),t._v(" "),n("li",[t._v("在多核时代，每颗 CPU 都有自己的缓存，因而不同线程操作的是不同的 CPU 缓存。所以如果线程 A 操作的是 CPU 1 上的缓存，线程 B 操作的是 CPU 2 上的缓存，那么线程 A 对变量的修改对于 B 来说就是不可见的了")])]),t._v(" "),n("h2",{attrs:{id:"源头之二-线程切换带来的原子性问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#源头之二-线程切换带来的原子性问题"}},[t._v("#")]),t._v(" 源头之二：线程切换带来的原子性问题")]),t._v(" "),n("p",[t._v("操作系统允许某个线程执行一段时间，等过了一个时间片后，就会重新选择一个线程来执行，这个过程为“线程切换”，进行“线程切换”可以防止由于执行长作业而导致的其他作业长时间得不到执行\n现在基本采用高级语言编程，一条高级语言的执行往往需要多条 CPU 指令完成\n例如完成"),n("code",[t._v("count += 1")]),t._v("，至少需要三条指令：")]),t._v(" "),n("ol",[n("li",[t._v("将变量 count 的值从内存中加载到 CPU 寄存器里")]),t._v(" "),n("li",[t._v("将 count 的值 + 1")]),t._v(" "),n("li",[t._v("将 count 的新值写入内存中（缓存机制可能导致写入的是 CPU 缓存而不是内存）")])]),t._v(" "),n("p",[t._v("而操作系统进行“线程切换”可以发生在任何一条 CPU 指令执行完（而不是高级语言中的一条语句），如果内存中的 count = 0，且线程 A 在指令 1 执行完后进行了线程切换，那么结果会跟预期不一致，如下：\n"),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/lorrainecyw/PhotoStorage@main/blogImage/1659341934664-4889f853-1561-4520-b00e-b2262e79927f.jpeg",alt:""}})]),t._v(" "),n("p",[t._v("所以说 CPU 能保证的原子性是 CPU 指令级别的，而非高级语言的语句级别的")]),t._v(" "),n("h2",{attrs:{id:"源头之三-编译优化带来的有序性问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#源头之三-编译优化带来的有序性问题"}},[t._v("#")]),t._v(" 源头之三：编译优化带来的有序性问题")]),t._v(" "),n("p",[t._v("有序性指的是程序按照代码的先后顺序来执行，但有时候编译器为了优化性能，会调整代码的执行顺序，例如"),n("code",[t._v("a = 7; b = 8;")]),t._v("会变成"),n("code",[t._v("b = 8; a = 7;")]),t._v("，一般来说，编译器调整了语句的执行顺序，但并不会影响程序的最终结果，但有时候会出现意想不到的 bug\n例如【双重检查创建单例对象】这个例子，代码如下：")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" instance"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInstance")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instance "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instance "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t\t\tinstance "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\t\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" instance"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br"),n("span",{staticClass:"line-number"},[t._v("9")]),n("br"),n("span",{staticClass:"line-number"},[t._v("10")]),n("br"),n("span",{staticClass:"line-number"},[t._v("11")]),n("br"),n("span",{staticClass:"line-number"},[t._v("12")]),n("br"),n("span",{staticClass:"line-number"},[t._v("13")]),n("br"),n("span",{staticClass:"line-number"},[t._v("14")]),n("br"),n("span",{staticClass:"line-number"},[t._v("15")]),n("br")])]),n("p",[t._v("假设线程 A 和线程 B 同时调用了"),n("code",[t._v("getInstance()")]),t._v("，这两个线程会发现"),n("code",[t._v("instance == null")]),t._v("，然后就会同时对"),n("code",[t._v("Singleton.class")]),t._v("加锁，只有一个线程能获得锁，假设是 A 获得了锁，那么 A 发现这时"),n("code",[t._v("instance")]),t._v("仍然等于 null，那么 A 会创建一个"),n("code",[t._v("Singleton")]),t._v("实例，然后释放锁。接下来 B 获得了锁，B 进行"),n("code",[t._v("instance == null")]),t._v("判断的时候，发现此时"),n("code",[t._v("instance != null")]),t._v("，于是 B 就不会再创建一个实例对象了\n但是问题出现在"),n("code",[t._v("instance = new Singleton()")]),t._v("，我们认为的 new 操作有以下几步：")]),t._v(" "),n("ol",[n("li",[t._v("分配一块内存 M")]),t._v(" "),n("li",[t._v("在内存 M 上初始化 Singleton 对象")]),t._v(" "),n("li",[t._v("将 M 的地址赋值给 instance 变量")])]),t._v(" "),n("p",[t._v("但是编译器优化后，执行的顺序却是这样的：")]),t._v(" "),n("ol",[n("li",[t._v("分配一块内存 M")]),t._v(" "),n("li",[t._v("将 M 的地址赋值给 instance 变量")]),t._v(" "),n("li",[t._v("在内存 M 上初始化 Singleton 对象")])]),t._v(" "),n("p",[t._v("假设线程 A 先执行"),n("code",[t._v("getInstance()")]),t._v("，当执行完 new 操作的第二条指令的时候，发生了“线程切换”，也就是此时 instance 的值为 M 的地址，但是还没有初始化 Singleton 对象。线程切换到了线程 B 上，线程 B 执行"),n("code",[t._v("getInstance()")]),t._v("，判断"),n("code",[t._v("instance == null")]),t._v(" 时，发现"),n("code",[t._v("instance != null")]),t._v("，就不会再进行下去了，此时的 instance 没有初始化过，如果这时访问 instance 就可能会触发空指针异常")])])}),[],!1,null,null,null);s.default=e.exports}}]);