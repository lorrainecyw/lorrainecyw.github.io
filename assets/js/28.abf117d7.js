(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{763:function(t,s,a){"use strict";a.r(s);var n=a(11),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("局部变量，也称内部变量，是指"),a("strong",[t._v("在一个函数内部或复合语句内部定义的变量")]),t._v("，局部变量是线程安全的")])]),t._v(" "),a("p",[t._v("以斐波那契数列为例，根据传入的参数 n ，返回 1 到 n 的斐波那契数列，斐波那契数列类似这样： 1、1、2、3、5、8、13、21、34……第 1 项和第 2 项是 1，从第 3 项开始，每一项都等于前两项之和，代码如下：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回斐波那契数列")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fibonacci")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建结果数组")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" r "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化第一、第二个数")]),t._v("\n\tr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ①")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 计算 2..n")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br")])]),a("p",[t._v("可以看出，在这个方法中，创建了一个局部变量"),a("code",[t._v("int[] r")]),t._v("，通过数组 r 来保存每一项的值，那么对于 r ，是否存在数据竞争？显然是不存在的，而不存在的原因，就需要从弄清楚这个方法是怎么执行的，CPU 怎么将这些语句转换成指令来一条条执行 ？")]),t._v(" "),a("h2",{attrs:{id:"方法是如何被执行的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法是如何被执行的"}},[t._v("#")]),t._v(" 方法是如何被执行的")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fibonacci")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("上面的这个例子中，调用了"),a("code",[t._v("fibonacci")]),t._v("方法，针对第二条语句，CPU 执行指令的步骤分为以下几步：")]),t._v(" "),a("ol",[a("li",[t._v("先找到"),a("code",[t._v("fibonacci()")]),t._v("方法的地址")]),t._v(" "),a("li",[t._v("跳转到这个地址去执行方法的代码")]),t._v(" "),a("li",[t._v("执行完后，找到调用方法的下一条语句的地址（"),a("code",[t._v("int[] c = b;")]),t._v("的地址）")]),t._v(" "),a("li",[t._v("跳转到对应的地址再继续执行")])]),t._v(" "),a("h4",{attrs:{id:"cpu-是怎么找到调用方法的参数和返回地址的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu-是怎么找到调用方法的参数和返回地址的"}},[t._v("#")]),t._v(" CPU 是怎么找到调用方法的参数和返回地址的？")]),t._v(" "),a("p",[t._v("通过 CPU 的"),a("strong",[t._v("堆栈寄存器")]),t._v("。CPU 支持一种栈结构，这个栈和方法调用有关，被称为调用栈\n每个方法在调用栈里都有自己的独立空间，称为"),a("strong",[t._v("栈帧")]),t._v("。栈帧里面会存放方法需要的参数和返回地址。每调用一个方法，就回创建一个栈帧，并将栈帧压入调用栈，等到方法执行完成返回后，对应的栈帧会自动弹出。也就是说，栈帧与方法的生命周期一致，同生共死")]),t._v(" "),a("h4",{attrs:{id:"补充-递归太深-可能会导致栈溢出-sof-原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补充-递归太深-可能会导致栈溢出-sof-原因"}},[t._v("#")]),t._v(" 补充：递归太深，可能会导致栈溢出（SOF），原因 ？")]),t._v(" "),a("p",[t._v("每调用一个方法就会创建一个栈帧，并将栈帧压入调用栈，直到方法执行完成后才会弹出栈帧。而栈的大小不是无限的，而递归调用的特点是每递归一次，就要创建一个新的栈帧，而且还要保留之前的环境（栈帧），直到遇到结束条件，所以栈容易被填满而导致栈溢出。所以递归调用一定要明确好结束条件，不要出现死循环")]),t._v(" "),a("h2",{attrs:{id:"局部变量存放在哪里"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#局部变量存放在哪里"}},[t._v("#")]),t._v(" 局部变量存放在哪里")]),t._v(" "),a("p",[t._v("局部变量的作用域是在方法内部，也就是当方法执行完成，局部变量也就没用了，所以局部变量与方法也是同生共死的，而栈帧与方法同样是同生共死的，那么很容易可以推断出，"),a("strong",[t._v("局部变量应当保存在调用栈的栈帧")]),t._v("中，事实也是如此。栈帧中不仅保存了方法需要的参数和返回地址，还保存了局部变量。局部变量保存在栈中，而创建的对象保存在堆中，如果变量想要跨越方法的边界，就得创建在堆中")]),t._v(" "),a("h4",{attrs:{id:"调用栈与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用栈与线程"}},[t._v("#")]),t._v(" 调用栈与线程")]),t._v(" "),a("p",[t._v("不同线程可以使用不同的参数调用相同的方法，每一个线程都有一个自己独立的调用栈，在自己的调用栈中创建栈帧来保存局部变量，那么线程之间也就互不打扰，局部变量自然也就是线程安全的了")]),t._v(" "),a("h4",{attrs:{id:"线程封闭"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程封闭"}},[t._v("#")]),t._v(" 线程封闭")]),t._v(" "),a("p",[t._v("方法中的局部变量由于存放在线程各自的调用栈中，不会被其他线程共享，没有并发问题，采用这种思路的技术叫做"),a("strong",[t._v("线程封闭")]),t._v("。线程封闭：仅在单线程内访问数据。因为不存在共享，所以也不存在并发\n采用线程封闭的案例有很多，例如解决数据库连接问题，数据库连接池通过线程封闭技术保证一个 connection 一旦被另一个线程获取后，在这个线程关闭 connection 之前，不会把它分配给其他线程")])])}),[],!1,null,null,null);s.default=r.exports}}]);