(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{755:function(v,t,_){"use strict";_.r(t);var a=_(11),r=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"安全性问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安全性问题"}},[v._v("#")]),v._v(" 安全性问题")]),v._v(" "),_("p",[v._v("线程安全：如果程序在单线程下和多线程下运行的结果一致，那么就是线程安全的\n理论上，线程安全的程序要避免原子性问题、可见性问题、有序性问题。而产生这三种问题归根结底就是产生了这种情况：存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据\n多个线程同时读写同一数据，会产生数据竞争还有"),_("strong",[v._v("竞态条件")]),v._v("问题。竞态条件，指的是程序的执行结果依赖线程执行的顺序。在并发环境里，线程的执行顺序是不确定的，如果程序存在竞态条件问题，那就意味着程序执行的结果是不确定的，而执行结果不确定这可是个大 Bug\n那面对数据竞争和竞态条件问题，又该如何保证线程的安全性呢？其实这两类问题，都可以用互斥这个技术方案，而实现互斥的方案有很多，CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API。从逻辑上来看，我们可以统一归为："),_("strong",[v._v("锁")])]),v._v(" "),_("h2",{attrs:{id:"活跃性问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#活跃性问题"}},[v._v("#")]),v._v(" 活跃性问题")]),v._v(" "),_("p",[v._v("所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是“活锁”和“饥饿”")]),v._v(" "),_("ol",[_("li",[v._v("所谓“活锁”指的是线程虽然没有发生阻塞，但仍然存在执行不下去的情况（多个线程类似死锁的情况下，同时释放掉自己已经获取的资源，然后同时获取另外一种资源，又形成依赖循环，导致都不能执行下去），总的来说就是同时放弃却又同时竞争")]),v._v(" "),_("li",[v._v("所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况")])]),v._v(" "),_("h4",{attrs:{id:"解决-活锁-问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决-活锁-问题"}},[v._v("#")]),v._v(" 解决“活锁”问题")]),v._v(" "),_("p",[v._v("在线程放弃资源的时候，设置一个随机的时间，等随机时间过了再去获取资源，这样线程同时竞争的情况就会大大减少，避免了同时放弃却又同时竞争的情况的发生")]),v._v(" "),_("h4",{attrs:{id:"解决-饥饿-问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决-饥饿-问题"}},[v._v("#")]),v._v(" 解决“饥饿”问题")]),v._v(" "),_("ol",[_("li",[v._v("保证资源充足")]),v._v(" "),_("li",[v._v("公平地分配资源")]),v._v(" "),_("li",[v._v("避免持有锁的线程长时间执行")])]),v._v(" "),_("p",[v._v("这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些（通过公平锁实现）")]),v._v(" "),_("h2",{attrs:{id:"性能问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能问题"}},[v._v("#")]),v._v(" 性能问题")]),v._v(" "),_("p",[v._v("在使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能")]),v._v(" "),_("h4",{attrs:{id:"判断性能的三大指标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#判断性能的三大指标"}},[v._v("#")]),v._v(" 判断性能的三大指标")]),v._v(" "),_("ol",[_("li",[v._v("吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好")]),v._v(" "),_("li",[v._v("延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好")]),v._v(" "),_("li",[v._v("并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒")])]),v._v(" "),_("h4",{attrs:{id:"如何防止锁过度使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何防止锁过度使用"}},[v._v("#")]),v._v(" 如何防止锁过度使用")]),v._v(" "),_("ol",[_("li",[v._v("既然使用锁会带来性能问题，那最好的方案自然就是"),_("strong",[v._v("使用无锁的算法和数据结构")]),v._v("了。在这方面有很多相关的技术，例如线程本地存储（"),_("code",[v._v("Thread Local Storage")]),v._v("，"),_("code",[v._v("TLS")]),v._v("）、写入时复制（"),_("code",[v._v("Copy-on-write")]),v._v("）、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；"),_("code",[v._v("Disruptor")]),v._v(" 则是一个无锁的内存队列，性能都非常好……")]),v._v(" "),_("li",[_("strong",[v._v("减少锁持有的时间")]),v._v("。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 "),_("code",[v._v("ConcurrentHashMap")]),v._v("，它使用了所谓分段锁的技术（"),_("code",[v._v("JDK 1.7及之前")]),v._v("）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥")])])])}),[],!1,null,null,null);t.default=r.exports}}]);