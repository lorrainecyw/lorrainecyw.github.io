(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{784:function(e,v,_){"use strict";_.r(v);var r=_(11),o=Object(r.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("blockquote",[_("p",[e._v("本讲重点：")]),e._v(" "),_("ul",[_("li",[e._v("change buffer 的工作机制")]),e._v(" "),_("li",[e._v("change buffer 与 redolog 的区别")]),e._v(" "),_("li",[e._v("普通索引和唯一索引如何选择")])])]),e._v(" "),_("h2",{attrs:{id:"普通索引和唯一索引的比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#普通索引和唯一索引的比较"}},[e._v("#")]),e._v(" 普通索引和唯一索引的比较")]),e._v(" "),_("h3",{attrs:{id:"查询过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查询过程"}},[e._v("#")]),e._v(" 查询过程")]),e._v(" "),_("blockquote",[_("p",[e._v("例："),_("code",[e._v("select * from T where k = 5")]),e._v("，在字段 k 上加索引")])]),e._v(" "),_("ul",[_("li",[e._v("对于普通索引来说，先找到第一行满足条件（k = 5）的记录，然后继续往下查找并判断下一条记录，直到遇到第一个不满足条件的记录")]),e._v(" "),_("li",[e._v("对于唯一索引来说，找到第一行满足条件（k = 5）的记录，就可以返回了")])]),e._v(" "),_("p",[_("strong",[e._v("分析")]),e._v("：普通索引相对而言，多了一步继续查找并判断下一条记录。由于 InnoDB 读写数据的单位为页，是按数据页一页一页读取到内存中的。如果接下来的记录都在同一个数据页中，那么花费的时间几乎可以省略不计；如果下一条记录在另一个数据页中，那么需要多读一个数据页，操作会复杂一些，但是之前经过计算，对于整型字段，一个数据页可以存放近千个 key，所以遇到这种情况的概率会很低，认为这个操作成本对于 CPU 来说可以忽略不计\n"),_("strong",[e._v("总结")]),e._v("：从查询语句的执行过程中，可以发现普通索引和唯一索引的平均性能差异不大，可忽略不计")]),e._v(" "),_("h3",{attrs:{id:"更新过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#更新过程"}},[e._v("#")]),e._v(" 更新过程")]),e._v(" "),_("h4",{attrs:{id:"change-buffer-的简单介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer-的简单介绍"}},[e._v("#")]),e._v(" change buffer 的简单介绍")]),e._v(" "),_("p",[_("strong",[e._v("具体作用")]),e._v("：更新数据的时候，如果要更新的数据页在内存中，那就直接更新内存中的数据页，如果不在内存中，那么会将更新操作缓存在"),_("code",[e._v("change buffer")]),e._v("中，等到后面查询这个数据页的数据时，将整个内存页读入内存，取出"),_("code",[e._v("change buffer")]),e._v("中和这个数据页有关的更新操作，应用在数据页上\n"),_("strong",[e._v("持久化")]),e._v("："),_("code",[e._v("change buffer")]),e._v("中的数据是可以持久化的数据，"),_("code",[e._v("change buffer")]),e._v("在内存中有拷贝，也会被写入磁盘\n"),_("strong",[e._v("定期 merge")]),e._v("：将"),_("code",[e._v("change buffer")]),e._v("中的操作应用到数据页，并得到新的数据结果的过程成为"),_("code",[e._v("merge")]),e._v("。除了访问这个数据页的时候会"),_("code",[e._v("merge")]),e._v("，系统有后台线程会定期"),_("code",[e._v("merge")]),e._v("，在数据库正常关闭的过程中，也会"),_("code",[e._v("merge")]),e._v(" "),_("strong",[e._v("优点")]),e._v("：")]),e._v(" "),_("ol",[_("li",[e._v("提高更新速度：将更新操作先缓存在"),_("code",[e._v("change buffer")]),e._v("中，减少读磁盘，加快了更新语句的执行速度")]),e._v(" "),_("li",[e._v("减少内存占用：把数据页读入内存需要占用"),_("code",[e._v("buffer pool")]),e._v("，而使用"),_("code",[e._v("change buffer")]),e._v("时，更新语句不需要读入数据页，避免占用内存，提高内存利用率")])]),e._v(" "),_("h4",{attrs:{id:"什么情况可以使用-change-buffer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么情况可以使用-change-buffer"}},[e._v("#")]),e._v(" 什么情况可以使用 change buffer")]),e._v(" "),_("p",[e._v("唯一索引的更新过程会比普通索引多一步：判断该字段是否有冲突。为了判断是否有冲突，就必须将这个数据页读入内存中，取出数据来判断，既然已经将数据页读入内存了，那么就可以直接在数据页上进行更新了，而不需要将更新操作缓存在"),_("code",[e._v("change buffer")]),e._v("中了，毕竟"),_("code",[e._v("change buffer")]),e._v("也要占用"),_("code",[e._v("buffer pool")]),e._v("中的内存。由此可得，唯一索引用不上"),_("code",[e._v("change buffer")]),e._v(" "),_("strong",[e._v("更新过程如下")]),e._v("：")]),e._v(" "),_("blockquote",[_("p",[e._v("例：插入（4，400）这条新记录，表里原来有（2，200）、（3，300）、（5，500）这 3 行记录")])]),e._v(" "),_("ol",[_("li",[e._v("要更新的数据页在内存中\n"),_("ol",[_("li",[e._v("普通索引：找到 3 和 5 之间的位置，插入新记录，语句执行结束")]),e._v(" "),_("li",[e._v("唯一索引：找到 3 和 5 之间的位置，判断是否有冲突，如果没有就插入新记录，语句执行结束")])])]),e._v(" "),_("li",[e._v("要更新的数据页不在内存中\n"),_("ol",[_("li",[e._v("普通索引：将更新操作缓存在"),_("code",[e._v("change buffer")]),e._v("中，语句执行结束")]),e._v(" "),_("li",[e._v("唯一索引：将相应的数据页读入内存，判断是否有冲突，如果没有就插入新记录，语句执行结束")])])])]),e._v(" "),_("p",[e._v("从上面的例子可以看出，"),_("code",[e._v("change buffer")]),e._v("减少了随机磁盘访问，极大地提升了更新时的性能，因为将数据页读入内存涉及到随机 IO 的访问，是数据库里面成本最高的操作之一\n而且可以看出，"),_("code",[e._v("change buffer")]),e._v("中缓存的更新操作越多，减少随机磁盘访问的次数就越多，性能的提升就越大，所以"),_("code",[e._v("change buffer")]),e._v("很适用于“写多读少”的场景，这样能在触发"),_("code",[e._v("merge")]),e._v("前，让缓存的更新操作尽可能多，例如账单类、日志类场景\n反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在"),_("code",[e._v("change buffer")]),e._v("中，但之后由于马上要访问这个数据页，会立即触发"),_("code",[e._v("merge")]),e._v("过程。这样随机访问 IO 的次数不会减少，反而增加了"),_("code",[e._v("change buffer")]),e._v("的维护代价。所以，对于这种业务模式来 说，"),_("code",[e._v("change buffer")]),e._v("反而起到了副作用。所以如果是这种情况，可以关闭"),_("code",[e._v("change buffer")]),e._v("来提高性能")]),e._v(" "),_("h4",{attrs:{id:"change-buffer-和-redolog-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer-和-redolog-的区别"}},[e._v("#")]),e._v(" change buffer 和 redolog 的区别")]),e._v(" "),_("p",[e._v("两者都是用于记录更新操作的，所以接下来针对更新过程进行分析：")]),e._v(" "),_("ol",[_("li",[e._v("要更新的数据页在内存中\n"),_("ol",[_("li",[_("code",[e._v("change buffer")]),e._v("：不记录")]),e._v(" "),_("li",[_("code",[e._v("redolog")]),e._v("：将更新操作记录在日志中，再将日志顺序写入磁盘")])])]),e._v(" "),_("li",[e._v("要更新的数据页不在内存中\n"),_("ol",[_("li",[_("code",[e._v("change buffer")]),e._v("：将更新操作缓存进来")]),e._v(" "),_("li",[_("code",[e._v("redolog")]),e._v("：将更新操作记录在日志中，再将日志顺序写入磁盘")])])])]),e._v(" "),_("p",[_("strong",[e._v("总结")]),e._v("："),_("code",[e._v("redolog")]),e._v("主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而"),_("code",[e._v("change buffer")]),e._v("主要节省的则是随机读磁盘的 IO 消耗")]),e._v(" "),_("h2",{attrs:{id:"两种索引的适用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两种索引的适用场景"}},[e._v("#")]),e._v(" 两种索引的适用场景")]),e._v(" "),_("ol",[_("li",[e._v("普通索引：在业务代码能够保证数据唯一性的情况下，可以使用普通索引")]),e._v(" "),_("li",[e._v("唯一索引：在业务代码无法保证正确，必须使用数据库来进行唯一性约束的时候，那就必须使用唯一索引，比如一些“归档库”，几乎不需要更新操作、确保没有唯一键冲突的场景都可以用唯一索引")])])])}),[],!1,null,null,null);v.default=o.exports}}]);