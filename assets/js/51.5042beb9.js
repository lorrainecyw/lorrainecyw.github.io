(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{786:function(t,_,v){"use strict";v.r(_);var a=v(11),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"全局锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[t._v("#")]),t._v(" 全局锁")]),t._v(" "),v("p",[t._v("全局锁，顾名思义，就是对整个数据库实例加锁\nMySQL 提供了一个加全局读锁的命令："),v("code",[t._v("Flush tables with read lock")]),t._v("（"),v("code",[t._v("FTWRL")]),t._v("）。加了全局读锁，整个数据库就处于只读的状态，所有执行 "),v("strong",[t._v("数据更新语句（数据的增删改）、数据定义语句（建表、修改表结构等）、更新类事务语句")]),t._v(" 的线程都会被阻塞")]),t._v(" "),v("h3",{attrs:{id:"全局逻辑备份"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局逻辑备份"}},[t._v("#")]),t._v(" 全局逻辑备份")]),t._v(" "),v("p",[t._v("全局锁的典型使用场景：做全局逻辑备份（把整库的所有表都 select 出来存成文本）\n备份时，数据库处于只读状态产生的影响：")]),t._v(" "),v("ul",[v("li",[t._v("在主库上进行备份，那么所有更新操作都会被阻塞，业务基本上得停摆")]),t._v(" "),v("li",[t._v("在从库上进行备份，那么备份期间记录主库上执行的更新操作的 binlog 就不能同步过来，会造成主从延迟")])]),t._v(" "),v("p",[t._v("备份时，不加锁会导致：备份系统备份得到的库不是同一个逻辑时间点的（备份得到的多个表处于不同的逻辑时间点），这个视图不是逻辑一致的\n解决方案：在备份开始前，在 "),v("strong",[t._v("可重复读隔离级别下开启一个事务")]),t._v("（保证视图的一致性），开启事务的语句")]),t._v(" "),v("h2",{attrs:{id:"表级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[t._v("#")]),t._v(" 表级锁")]),t._v(" "),v("p",[t._v("MySQL 中表级别的锁有两种：表锁、元数据锁（"),v("code",[t._v("MDL")]),t._v("，"),v("code",[t._v("Meta Data Lock")]),t._v("）")]),t._v(" "),v("h3",{attrs:{id:"表锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[t._v("#")]),t._v(" 表锁")]),t._v(" "),v("p",[t._v("表锁的语法是"),v("code",[t._v("lock tables …… read/write")]),t._v("（省略号处填的是表名），可以用"),v("code",[t._v("unlock tables")]),t._v("主动释放锁，也可以等客户端断开的时候自动释放锁。加表锁除了限制其他线程的操作对象，也会限制本线程自己的操作对象\n例：线程 A 执行"),v("code",[t._v("lock tables t1 read, t2 write;")]),t._v("\n上面的例子中，线程 A 向 t1 加了读锁，t2 加了写锁，那么其他线程【写 t1、读写 t2】的操作都会被阻塞，而线程 A 本身也只能【读 t1、读写 t2】，不能【写 t1】")]),t._v(" "),v("h3",{attrs:{id:"元数据锁-mdl"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#元数据锁-mdl"}},[t._v("#")]),t._v(" 元数据锁（MDL）")]),t._v(" "),v("p",[t._v("MDL 不需要显示使用，访问一张表的时候会自动加上，它的作用是保证读写的准确性\n加锁的情况：")]),t._v(" "),v("ol",[v("li",[t._v("如果进行的是增删改查操作，那么加的是 MDL 读锁")]),t._v(" "),v("li",[t._v("如果进行的是表结构的变更操作，那么加的是 MDL 写锁")])]),t._v(" "),v("p",[t._v("注意点：")]),t._v(" "),v("ul",[v("li",[t._v("MDL 读锁不互斥，也就是可以有多个线程加 MDL 读锁，可以有多个线程同时对一张表做增删改查；但 MDL 写锁是互斥的，同一时刻只能有一个线程加 MDL 写锁（并且需要等待读锁释放之后），其他线程需要等这个线程释放 MDL 写锁之后才能再加锁进行表结构的变更操作或者是增删改查的操作")]),t._v(" "),v("li",[t._v("事务中的 MDL 锁在语句开始执行时申请，而且需要"),v("strong",[t._v("等到事务提交之后才会释放")]),t._v("。也就是如果事务不提交，就会一直占着 MDL 锁。在MySQL的"),v("code",[t._v("information_schema")]),t._v("库的"),v("code",[t._v("innodb_trx")]),t._v("表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务")])])])}),[],!1,null,null,null);_.default=e.exports}}]);