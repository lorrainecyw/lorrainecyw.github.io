(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{768:function(t,s,a){"use strict";a.r(s);var n=a(11),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("Java 中的容器主要可以分为四个大类，分别是 List、Map、Set 和 Queue，但并不是所有的 Java 容器都是线程安全的。例如，常用的 ArrayList、HashMap 就不是线程安全的\n"),a("strong",[t._v("如何将非线程安全的容器变成线程安全的容器？")]),t._v("\n把非线程安全的容器封装在对象内部，然后控制好访问路径就可以了。以"),a("code",[t._v("ArrayList")]),t._v("为例，创建一个类"),a("code",[t._v("SafeArrayList")]),t._v("，这个类内部持有一个"),a("code",[t._v("ArrayList")]),t._v("的实例 c，所有访问 c 的方法都增加上"),a("code",[t._v("synchronized")]),t._v("关键字，这样就能够保证线程安全了")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SafeArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 封装 ArrayList")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 控制访问路径")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("idx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addIfNotExist")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("contains")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\tc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br")])]),a("h2",{attrs:{id:"同步容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步容器"}},[t._v("#")]),t._v(" 同步容器")]),t._v(" "),a("p",[t._v("Java 在"),a("code",[t._v("Collections")]),t._v("这个类中，提供了一套完备的包装类，分别把ArrayList、HashSet 和 HashMap 包装成了线程安全的 List、Set 和 Map，也是基于"),a("code",[t._v("synchronized")]),t._v("关键字实现的")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collections")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronizedList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Set")]),t._v(" set "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collections")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronizedSet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashSet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),t._v(" map "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collections")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("synchronizedMap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("曾经强过调，组合操作需要注意竞态条件问题，例如上面提到的"),a("code",[t._v("addIfNotExist()")]),t._v("方法就包含组合操作。在容器领域一个容易被忽视的“坑”是用"),a("strong",[t._v("迭代器遍历容器")]),t._v("，使用组合操作的话会存在并发问题，应该加锁锁住 list 之后再执行遍历操作\n上面提到的这些经过包装后线程安全容器，都是基于"),a("code",[t._v("synchronized")]),t._v("这个同步关键字实现的，所以也被称为同步容器。Java 提供的同步容器还有"),a("code",[t._v("Vector")]),t._v("、"),a("code",[t._v("Stack")]),t._v("和"),a("code",[t._v("Hashtable")]),t._v("，这三个容器不是基于包装类实现的，但同样是基于"),a("code",[t._v("synchronized")]),t._v("实现的，对这三个容器的遍历，同样要加锁保证互斥")]),t._v(" "),a("h2",{attrs:{id:"并发容器及其注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发容器及其注意事项"}},[t._v("#")]),t._v(" 并发容器及其注意事项")]),t._v(" "),a("p",[t._v("同步容器有个最大的问题 —— 性能差，所有方法都用"),a("code",[t._v("synchronized")]),t._v("来保证互斥，串行度太高了。因此 Java 在 "),a("strong",[t._v("1.5 及之后")]),t._v("版本提供了性能更高的容器 —— 并发容器。并发容器虽然数量非常多，但依然是这四大类：List、Map、Set 、Queue")]),t._v(" "),a("h3",{attrs:{id:"_1-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-list"}},[t._v("#")]),t._v(" 1. List")]),t._v(" "),a("p",[t._v("List 里面只有一个实现类就是"),a("code",[t._v("CopyOnWriteArrayList")]),t._v("。"),a("code",[t._v("CopyOnWrite")]),t._v("，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。")]),t._v(" "),a("h4",{attrs:{id:"copyonwritearraylist-的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyonwritearraylist-的实现原理"}},[t._v("#")]),t._v(" CopyOnWriteArrayList 的实现原理")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("CopyOnWriteArrayList")]),t._v("内部维护了一个数组，成员变量"),a("code",[t._v("array")]),t._v("就指向这个内部数组，所有的读操作都是基于"),a("code",[t._v("array")]),t._v("进行的，迭代器"),a("code",[t._v("Iterator")]),t._v("遍历的就是"),a("code",[t._v("array")]),t._v("数组")]),t._v(" "),a("li",[t._v("如果在遍历的同时，还有一个写操作，例如增加元素，"),a("code",[t._v("CopyOnWriteArrayList")]),t._v("会将"),a("code",[t._v("array")]),t._v("复制一份，然后在"),a("strong",[t._v("新复制处理的数组")]),t._v("上执行增加元素的操作，执行完之后再将"),a("code",[t._v("array")]),t._v("指向这个新的数组。也就是说，"),a("strong",[t._v("读写是可以并行的")]),t._v("，遍历操作一直都是基于原"),a("code",[t._v("array")]),t._v("执行，而写操作则是基于新"),a("code",[t._v("array")]),t._v("进行")])]),t._v(" "),a("h4",{attrs:{id:"注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("CopyOnWriteArrayList")]),t._v("需要注意的“坑”主要有两个方面")]),t._v(" "),a("ol",[a("li",[t._v("应用场景。"),a("code",[t._v("CopyOnWriteArrayList")]),t._v("仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。如果在遍历的过程中，写入的新元素并不能立刻被遍历到。")]),t._v(" "),a("li",[a("code",[t._v("CopyOnWriteArrayList")]),t._v("的迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的")])]),t._v(" "),a("h3",{attrs:{id:"_2-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-map"}},[t._v("#")]),t._v(" 2. Map")]),t._v(" "),a("p",[t._v("Map 接口的两个实现是"),a("code",[t._v("ConcurrentHashMap")]),t._v("和"),a("code",[t._v("ConcurrentSkipListMap")])]),t._v(" "),a("ul",[a("li",[t._v("主要区别在于"),a("code",[t._v("ConcurrentHashMap")]),t._v("的 key 是无序的，而"),a("code",[t._v("ConcurrentSkipListMap")]),t._v("的 key 是有序的。所以如果需要保证 key 的顺序，就只能使用"),a("code",[t._v("ConcurrentSkipListMap")]),t._v("。")]),t._v(" "),a("li",[t._v("两者的 key 和 value 都不能为空，否则会抛出"),a("code",[t._v("NullPointerException")]),t._v("这个运行时异常")]),t._v(" "),a("li",[t._v("ConcurrentSkipListMap 里面的 SkipList 本身就是一种数据结构，称为“跳表”。跳表插入、删除、查询操作平均的时间复杂度是 "),a("em",[t._v("O(log n)")]),t._v("，理论上和并发线程数没有关系，所以在并发度非常高的情况下，如果对"),a("code",[t._v("ConcurrentHashMap")]),t._v("的性能还不满意，可以尝试一下"),a("code",[t._v("ConcurrentSkipListMap")])])]),t._v(" "),a("h3",{attrs:{id:"_3-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-set"}},[t._v("#")]),t._v(" 3. Set")]),t._v(" "),a("p",[t._v("Set 接口的两个实现是"),a("code",[t._v("CopyOnWriteArraySet")]),t._v("和"),a("code",[t._v("ConcurrentSkipListSe")]),t._v("，原理与前面讲述的 "),a("code",[t._v("CopyOnWriteArrayList")]),t._v("和"),a("code",[t._v("ConcurrentSkipListMap")]),t._v("是一样的")]),t._v(" "),a("h3",{attrs:{id:"_4-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-queue"}},[t._v("#")]),t._v(" 4. Queue")]),t._v(" "),a("h4",{attrs:{id:"分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[t._v("#")]),t._v(" 分类")]),t._v(" "),a("p",[t._v("可以从以下两个维度来分类：")]),t._v(" "),a("ol",[a("li",[t._v("阻塞与非阻塞。所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞")]),t._v(" "),a("li",[t._v("单端与双端，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队")])]),t._v(" "),a("p",[t._v("Java 并发包里阻塞队列都用"),a("code",[t._v("Blocking")]),t._v("关键字标识，单端队列使用"),a("code",[t._v("Queue")]),t._v("标识，双端队列使用"),a("code",[t._v("Deque")]),t._v("标识\n这两个维度组合后，可以将 Queue 细分为四大类，分别是：")]),t._v(" "),a("ol",[a("li",[t._v("单端阻塞队列：实现类有"),a("code",[t._v("ArrayBlockingQueue")]),t._v("、"),a("code",[t._v("LinkedBlockingQueue")]),t._v("、"),a("code",[t._v("SynchronousQueue")]),t._v("、"),a("code",[t._v("LinkedTransferQueue")]),t._v("、"),a("code",[t._v("PriorityBlockingQueue")]),t._v("和"),a("code",[t._v("DelayQueue")]),t._v(" "),a("ul",[a("li",[t._v("内部一般会持有一个队列，这个队列可以是数组（"),a("code",[t._v("ArrayBlockingQueue")]),t._v("）也可以是链表（"),a("code",[t._v("LinkedBlockingQueue")]),t._v("）；甚至还可以不持有队列（"),a("code",[t._v("SynchronousQueue")]),t._v("），此时生产者线程的入队操作必须等待消费者线程的出队操作")]),t._v(" "),a("li",[t._v("而 "),a("code",[t._v("LinkedTransferQueue")]),t._v("融合了"),a("code",[t._v("LinkedBlockingQueue")]),t._v("和"),a("code",[t._v("SynchronousQueue")]),t._v("的功能，性能比 "),a("code",[t._v("LinkedBlockingQueue")]),t._v("更好")]),t._v(" "),a("li",[a("code",[t._v("PriorityBlockingQueue")]),t._v(" 支持按照优先级出队")]),t._v(" "),a("li",[a("code",[t._v("DelayQueue")]),t._v("支持延时出队")])])]),t._v(" "),a("li",[t._v("双端阻塞队列："),a("code",[t._v("LinkedBlockingDeque")])]),t._v(" "),a("li",[t._v("单端非阻塞队列："),a("code",[t._v("ConcurrentLinkedQueue")])]),t._v(" "),a("li",[t._v("双端非阻塞队列："),a("code",[t._v("ConcurrentLinkedDeque")])])]),t._v(" "),a("h4",{attrs:{id:"注意事项-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事项-2"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),a("p",[t._v("使用队列时，需要格外注意队列"),a("strong",[t._v("是否支持有界")]),t._v("（所谓有界指的是内部的队列是否有"),a("strong",[t._v("容量限制")]),t._v("）。实际工作中，一般都不建议使用无界的队列，因为数据量大了之后很容易导致"),a("code",[t._v("OOM")]),t._v("（"),a("code",[t._v("Out Of Memory")]),t._v("）。上面提到的这些队列中中，只有"),a("code",[t._v("ArrayBlockingQueue")]),t._v("和"),a("code",[t._v("LinkedBlockingQueue")]),t._v("是支持有界的，所以在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患")])])}),[],!1,null,null,null);s.default=e.exports}}]);