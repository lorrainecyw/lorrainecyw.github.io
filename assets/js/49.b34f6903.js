(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{780:function(v,_,t){"use strict";t.r(_);var n=t(11),e=Object(n.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"索引基本介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#索引基本介绍"}},[v._v("#")]),v._v(" 索引基本介绍")]),v._v(" "),t("blockquote",[t("p",[v._v("索引：为了提高数据的查询效率而出现的，相当于书的“目录”")])]),v._v(" "),t("p",[v._v("索引常见的 3 种数据结构：")]),v._v(" "),t("ul",[t("li",[v._v("哈希表：以"),t("code",[v._v("key-value")]),v._v("键值对的形式来存储数据，适用于等值查询\n"),t("ul",[t("li",[v._v("存放数据的方式：将值放在一个数组中，通过 hash 函数将 key 转换成一个下标，存放在数组中，多个 key 可能经过转换后得到的值相同，所以数组的每个元素都是一个链表")]),v._v(" "),t("li",[v._v("由于数组中存放的值并不是递增的，所以只适用于等值查询")])])]),v._v(" "),t("li",[v._v("有序数组：按数据大小递增存放数据，适用于等值查询、范围查询\n"),t("ul",[t("li",[v._v("查询数据时，通过二分法快速得到数据，时间复杂度为 "),t("em",[v._v("O(N)")]),v._v(" 。如果是范围查询，需要查询"),t("code",[v._v("[X,Y]")]),v._v("区间的数据，那么可以先用二分法找到"),t("code",[v._v(">= X")]),v._v("的第一个数据，然后往后一次遍历，直到值大于 Y")]),v._v(" "),t("li",[v._v("由于数组递增存放数据，所以添加数据时可能需要挪动后面的数据，成本高，所以只适用于静态存储引擎，即不会进行修改的数据")])])]),v._v(" "),t("li",[v._v("搜索树（二叉树、B+ 树、B 树等）")])]),v._v(" "),t("p",[v._v("在 MySQL 中，索引是在 "),t("strong",[v._v("存储引擎层")]),v._v(" 实现的。所以不同存储引擎的索引工作方式并不同，即使支持同一类型的索引，底层实现可能也会不同")]),v._v(" "),t("h2",{attrs:{id:"innodb-的索引模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb-的索引模型"}},[v._v("#")]),v._v(" InnoDB 的索引模型")]),v._v(" "),t("p",[v._v("在 InnoDB 中，表都是根据 "),t("strong",[v._v("主键顺序")]),v._v(" 以索引的形式存放的，所以这种存储方式称为“索引组织表”\n在 InnoDB 中，主键索引也称为聚簇索引"),t("code",[v._v("clustered index")]),v._v("，非主键索引也称为二级索引"),t("code",[v._v("Secondary index")]),v._v("\nInnoDB 采用的索引模型是 "),t("strong",[v._v("B+ 树")]),v._v("，每个索引对应一棵 B+ 树，所以数据也是存放在 B+ 树中的\nB+ 树的特点：只在叶子节点存放具体，其他节点存放索引数据\n主键索引的叶子节点存放的是 "),t("strong",[v._v("整行的数据")]),v._v("，非主键索引的叶子节点存放的是 "),t("strong",[v._v("主键的值")]),v._v("\n所以如果通过普通索引查询方式（例如：id 为主键，字段 k 上有索引，"),t("code",[v._v("select * from T where k = 5")]),v._v("），那么就需要先通过 k 的索引树取到主键值，然后再到主键的索引树获取整行数据，以上过程就称为“"),t("strong",[v._v("回表")]),v._v("”。所以应尽量使用主键查询\n注意：InnoDB 读取数据是以页为单位的，如果查询的记录不在内存中，就将包含该记录的数据页整页读入内存中")]),v._v(" "),t("h4",{attrs:{id:"为什么要使用自增主键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用自增主键"}},[v._v("#")]),v._v(" 为什么要使用自增主键 ？")]),v._v(" "),t("ol",[t("li",[v._v("由于 B+ 树是有序的，为了维护索引的有序性，如果不使用自增主键，那么可能就会往数据页的中间插入记录，就需要挪动后面的记录，如果这一页已经满了的话，那么就需要申请新的数据页，然后把部分数据放到新的数据页，再插入这行新记录，这就造成了**页分裂 **。页分裂不仅导致维护成本高、还影响性能、降低页面利用率")]),v._v(" "),t("li",[v._v("自增主键能够保证数据递增插入，每次插入都是追加操作，不会造成页分裂")]),v._v(" "),t("li",[v._v("自增 id 如果使用 int 型只需要 4 个字节来保存，使用 bigint 型只需要 8 个字节来保存，但使用业务字段很可能就不止这些字节了。主键长度越小，索引的叶子节点就越小，普通索引占用的空间就越小")])]),v._v(" "),t("h4",{attrs:{id:"不使用自增主键的场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不使用自增主键的场景"}},[v._v("#")]),v._v(" 不使用自增主键的场景")]),v._v(" "),t("p",[v._v("只有一个索引，且该索引为唯一索引，那么就可以使用该索引作为主键，查询时就可以避免查询两棵索引树")]),v._v(" "),t("h4",{attrs:{id:"补充-为什么采用-b-树作为索引模型-而不是-b-树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充-为什么采用-b-树作为索引模型-而不是-b-树"}},[v._v("#")]),v._v(" 补充：为什么采用 B+ 树作为索引模型 ？（而不是 B 树）")])])}),[],!1,null,null,null);_.default=e.exports}}]);