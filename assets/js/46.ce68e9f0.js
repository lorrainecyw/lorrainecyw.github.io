(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{778:function(_,v,t){"use strict";t.r(v);var e=t(11),a=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"mysql-基本结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-基本结构"}},[_._v("#")]),_._v(" MySQL 基本结构")]),_._v(" "),t("p",[_._v("MySQL 可以分为 Server 层和存储引擎层")]),_._v(" "),t("ul",[t("li",[_._v("Server 层：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心功能，以及所有的内置函数（日期等），所有跨存储引擎的功能都在这层实现，例如：存储过程、触发器、视图等")]),_._v(" "),t("li",[_._v("存储引擎层：负责数据的存储和读取。支持 InnoDB、Memory、MyISAM 等多个存储引擎")])]),_._v(" "),t("h3",{attrs:{id:"mysql-逻辑架构图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-逻辑架构图"}},[_._v("#")]),_._v(" MySQL 逻辑架构图")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://github.com/lorrainecyw/PhotoStorage/blob/main/blogImage/1656496954383-396819b8-22d9-4f5d-8cb4-3134357deb38.jpeg?raw=true",alt:""}})]),_._v(" "),t("h3",{attrs:{id:"连接器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接器"}},[_._v("#")]),_._v(" 连接器")]),_._v(" "),t("p",[_._v("作用：新建连接，权限验证，维持、管理连接\n"),t("strong",[_._v("一些注意点")])]),_._v(" "),t("ul",[t("li",[_._v("建立连接时，当用户名及密码验证成功后，连接器会到权限表中查出用户拥有的权限，然后当前连接里的权限判断就会依赖于当前查出来的权限。所以当连接建立后，就算改变了用户的权限，对于已经建立的连接不会有影响，只有之后建立的连接才会使用新的权限设置")]),_._v(" "),t("li",[_._v("当连接完成后，如果没有后续动作，那么连接就处于空闲状态。通过"),t("code",[_._v("show processlist")]),_._v("命令可以查询到进程处于"),t("code",[_._v("Sleep")]),_._v("状态")]),_._v(" "),t("li",[_._v("建立连接的过程通常比较复杂，所以建议尽量使用长连接（长连接：客户端与服务端建立连接成功后，如果客户端持续有请求，那么就一直使用同一个连接；短连接：每次连接建立之后执行完几次查询之后就断开，下次查询时再建立一个新连接）")])]),_._v(" "),t("p",[t("strong",[_._v("但是当全部都使用长连接后，会发现占用内存的上涨速度非常快，如何解决这个问题呢")])]),_._v(" "),t("ol",[t("li",[_._v("定期断开长连接。可以在使用一段时间后断开连接，也可以在程序里判断执行完一个占用内存大的查询后断开连接，之后再重连")]),_._v(" "),t("li",[_._v("通过"),t("code",[_._v("mysql_reset_connection")]),_._v("命令来重新初始化连接资源。在 MySQL 5.7 版本及更新的版本中可以使用该命令，这个命令不会重连，也不会重新验证权限，只会将连接恢复到刚建立的状态")])]),_._v(" "),t("h3",{attrs:{id:"查询缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询缓存"}},[_._v("#")]),_._v(" 查询缓存")]),_._v(" "),t("p",[_._v("执行过的语句及结果会以"),t("code",[_._v("key-value")]),_._v("键值对的形式直接缓存在内存中，key 是查询的语句，value 是查询执行的结果。所以执行查询语句时，会先到查询缓存中查找是否有相应的 key，如果命中了的话，就可以直接返回结果给客户端，不用再进行后面复杂的操作；如果没有命中，那么查询到结果后，会将结果存入查询缓存\n"),t("strong",[_._v("但是查询缓存有比较严重的弊端，弊端如下：")]),_._v("\n当表里有一个更新时，查询缓存里关于这个表的所有缓存都会直接清空，可能刚刚将许多数据存进去，还没有使用的时候就因为一个更新而全部清空了，这对于更新压力大的库来说，查询缓存的命中率会非常低。所以大多数情况下建议不要使用查询缓存\n"),t("strong",[_._v("解决方案：")]),_._v("\n根据 MySQL 提供的“按需使用”方式，将参数"),t("code",[_._v("query_cache_type")]),_._v("设置为"),t("code",[_._v("DEMAND")]),_._v("，这样查询语句默认不使用查询缓存，如果有语句需要使用查询缓存，那就在语句中加入"),t("code",[_._v("SQL_CACHE")]),_._v("来显式指定，例如"),t("code",[_._v("select SQL_CACHE * from T where id = 10;")]),_._v("\n注意：MySQL 8.0 将查询缓存的整块功能删除了，也就是之后更新的版本中也没有这个功能了")]),_._v(" "),t("h3",{attrs:{id:"分析器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析器"}},[_._v("#")]),_._v(" 分析器")]),_._v(" "),t("p",[_._v("作用：词法分析，语法分析（判断语句要 "),t("strong",[_._v("做什么")]),_._v("）\n先进行词法分析，再进行语法分析\n例："),t("code",[_._v("select * from T where id = 10;")]),_._v("\n词法分析：将"),t("code",[_._v("select")]),_._v("关键字识别出来，得出这是个查询语句，将 T 识别成“表 T”，将 id 识别成“列 id”\n语法分析：判断词法分析的结果是否符合 MySQL 的语法规则")]),_._v(" "),t("h3",{attrs:{id:"优化器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化器"}},[_._v("#")]),_._v(" 优化器")]),_._v(" "),t("p",[_._v("作用：选择索引，生成执行计划（决定该 "),t("strong",[_._v("怎么做")]),_._v("）\n当表里有多个索引时，决定使用哪个索引\n当语句中有多表连接时，决定表的连接顺序\n……\n通过判断执行的效率来决定使用哪个方案，生成执行计划")]),_._v(" "),t("h3",{attrs:{id:"执行器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行器"}},[_._v("#")]),_._v(" 执行器")]),_._v(" "),t("p",[_._v("作用：操作引擎，返回结果\n开始执行的时候，会先判断对表 T 是否有查询的权限，如果有，那么会根据优化器生成的执行计划来执行，操作引擎，返回结果；如果没有权限，会返回“没有权限”的错误")]),_._v(" "),t("h3",{attrs:{id:"存储引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储引擎"}},[_._v("#")]),_._v(" 存储引擎")]),_._v(" "),t("p",[_._v("作用：存储数据，提供读写接口\n不同存储引擎读取数据的方式不同，多个存储引擎共用同一个 Server 层，并且在 MySQL 5.5 及之后，InnoDB 成为了 MySQL 的默认引擎")]),_._v(" "),t("h2",{attrs:{id:"执行查询语句的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行查询语句的过程"}},[_._v("#")]),_._v(" 执行查询语句的过程")]),_._v(" "),t("p",[_._v("例："),t("code",[_._v("select * from T where id = 10;")])]),_._v(" "),t("h3",{attrs:{id:"id-字段上没有索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#id-字段上没有索引"}},[_._v("#")]),_._v(" id 字段上没有索引")]),_._v(" "),t("ol",[t("li",[_._v("执行器调用引擎接口取出表 T 的第一行，判断该行的 id 字段是否等于 10，如果等于就将这行加入结果集")]),_._v(" "),t("li",[_._v("继续调用引擎接口取出下一行，重复相同的逻辑，直到取到表 T 的最后一行")]),_._v(" "),t("li",[_._v("执行器将上述遍历中满足条件的行组成的结果集返回给客户端")])]),_._v(" "),t("h3",{attrs:{id:"id-字段上有索引-非唯一索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#id-字段上有索引-非唯一索引"}},[_._v("#")]),_._v(" id 字段上有索引（非唯一索引）")]),_._v(" "),t("ol",[t("li",[_._v("执行器调用引擎接口取出 **满足条件 **的第一行，将该行加入结果集")]),_._v(" "),t("li",[_._v("继续调用引擎接口取出满足条件的下一行，直到取出不满足条件的第一行为止")]),_._v(" "),t("li",[_._v("执行器将上述遍历中满足条件的行组成的结果集返回给客户端")])]),_._v(" "),t("h3",{attrs:{id:"id-字段上有唯一索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#id-字段上有唯一索引"}},[_._v("#")]),_._v(" id 字段上有唯一索引")]),_._v(" "),t("ol",[t("li",[_._v("执行器调用引擎接口取出 **满足条件 **的第一行，直接将该行返回给客户端")])])])}),[],!1,null,null,null);v.default=a.exports}}]);