(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{785:function(t,_,v){"use strict";v.r(_);var e=v(11),a=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("MySQL 的行锁是在引擎层由各个引擎实现的。MyISAM 不支持行锁，InnoDB 支持行锁")]),t._v(" "),v("blockquote",[v("p",[t._v("行锁：顾名思义，就是针对数据库表中行记录的锁。当两个或者多个事务在更新表里的同一行记录时，其他事务需要等待另一个事务更新完才能够继续更新，即同一时间只能有一个事务在更新同一行")])]),t._v(" "),v("h2",{attrs:{id:"两阶段锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两阶段锁"}},[t._v("#")]),t._v(" 两阶段锁")]),t._v(" "),v("p",[t._v("两阶段锁协议：事务的执行分两个阶段，第一个阶段为加锁阶段（生长阶段），第二个阶段为解锁阶段（衰退阶段）。在 InnoDB 的事务中，行锁是需要的时候才加上的，但是得等到 "),v("strong",[t._v("事务提交（事务结束）的时候才释放")]),t._v("\n由于上面的设定，在进行业务设计的时候，如果需要锁多行，那么对于容易造成锁冲突、最可能影响并发度的锁应该尽量往后放。这样能够减少这种锁的等待时间，降低锁冲突的可能性\n"),v("strong",[t._v("例子：顾客 A 要在影院 B 买电影票，应该如何设计业务的执行顺序？")]),t._v("\n这个业务需要进行的操作：")]),t._v(" "),v("ol",[v("li",[t._v("将顾客 A 的账户余额减掉票价")]),t._v(" "),v("li",[t._v("将影院 B 的账户余额加上票价")]),t._v(" "),v("li",[t._v("添加一条交易日志")])]),t._v(" "),v("p",[t._v("针对上面三个操作，需要写在同一个事务中，其中 2 是最可能造成锁冲突的（同一时刻有多个用户在同一个影院买票），所以需要将操作 2 放到最后执行，这样能最大程度减少事务之间的锁等待")]),t._v(" "),v("h2",{attrs:{id:"死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[t._v("#")]),t._v(" 死锁")]),t._v(" "),v("p",[t._v("有些时候并发的事务并不是特别多，但是 CPU 消耗却飙升到 100%，这种情况很有可能是因为进入了死锁状态")]),t._v(" "),v("h3",{attrs:{id:"造成死锁的情况一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#造成死锁的情况一"}},[t._v("#")]),t._v(" 造成死锁的情况一")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("t")]),t._v(" "),v("th",[t._v("事务 A")]),t._v(" "),v("th",[t._v("事务 B")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("t1")]),t._v(" "),v("td",[v("code",[t._v("begin; update T set k = k + 1 where id = 1;")])]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("t2")]),t._v(" "),v("td"),t._v(" "),v("td",[v("code",[t._v("begin;")])])]),t._v(" "),v("tr",[v("td",[t._v("t3")]),t._v(" "),v("td"),t._v(" "),v("td",[v("code",[t._v("update T set k = k + 1 where id = 2;")])])]),t._v(" "),v("tr",[v("td",[t._v("t4")]),t._v(" "),v("td",[v("code",[t._v("update T set k = k + 1 where id = 2;")])]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("t5")]),t._v(" "),v("td"),t._v(" "),v("td",[v("code",[t._v("update T set k = k + 1 where id = 1;")])])])])]),t._v(" "),v("p",[t._v("由上图可得，事务 A 获得了 id = 1 这行记录的锁，事务 B 获得了 id = 2 这行记录的锁，但由于两个事务都没有提交，所以这两个锁都没有释放，A 在 t4 时刻就被阻塞了，需要等待事务 B 释放锁，事务 B 也是同理，两者互相等待对方的资源释放，这就进入了死锁状态，两个事务进入无限等待")]),t._v(" "),v("h3",{attrs:{id:"解锁死锁的方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解锁死锁的方案"}},[t._v("#")]),t._v(" 解锁死锁的方案")]),t._v(" "),v("h4",{attrs:{id:"_1-超时等待"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-超时等待"}},[t._v("#")]),t._v(" 1. 超时等待")]),t._v(" "),v("p",[t._v("这种策略是直接进入等待，直到超时，被锁住的线程才会退出，可以通过修改参数"),v("code",[t._v("innodb_lock_wait_timeout")]),t._v("的值来修改超时时间\n这个时间默认为 50s，50s 对于在线业务来说有点过长，但是将时间改成 1s 的话，时间又过短，有可能只是正常的锁等待，并没有造成死锁，所以这个超时时间难以确定")]),t._v(" "),v("h4",{attrs:{id:"_2-死锁检测"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-死锁检测"}},[t._v("#")]),t._v(" 2. 死锁检测")]),t._v(" "),v("p",[t._v("一般来说，都是采用死锁检测的方法，将参数"),v("code",[t._v("innodb_deadlock_detect")]),t._v("设置为 on（默认也是 on），可以开启以下的逻辑：发起死锁检测，检测到死锁后，主动回滚死锁链条中的一个事务，让其他事务得以继续执行\n死锁检测的过程：每当一个事务被锁，就要查看它所依赖的线程有没有被锁住，如此循环，最后判断是否出现了循环等待，也就是死锁\n如果有 1000 个并发线程同时更新另一行，那么死锁检测操作就会达到百万级别，虽然最后检测出来是没有死锁的，但这个过程会消耗大量 CPU 资源，CPU 利用率会达到很高")]),t._v(" "),v("h5",{attrs:{id:"如何解决热点行更新导致的性能问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何解决热点行更新导致的性能问题"}},[t._v("#")]),t._v(" 如何解决热点行更新导致的性能问题")]),t._v(" "),v("ol",[v("li",[t._v("保证业务不会出现死锁，暂时关闭死锁检测（有风险）")]),t._v(" "),v("li",[t._v("控制并发度（在 MySQL 服务端做）\n"),v("ol",[v("li",[t._v("对于相同行的更新，在进入引擎前先排队")]),t._v(" "),v("li",[t._v("将一行改成逻辑上的多行（例如：影院的账户记录从一行改成多行，这样影院的账户余额就等于十行记录的总和，增加账户余额时可以随机从十行中选一行增加，但是业务需要多做判断，比如余额为 0 时就不能进行减法）")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);