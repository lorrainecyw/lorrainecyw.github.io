(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{783:function(_,t,v){"use strict";v.r(t);var e=v(11),o=Object(e.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("blockquote",[v("p",[_._v("阅读本讲时，可以回顾一下 03 讲，有利于理解事务及加深印象")])]),_._v(" "),v("p",[_._v("MySQL 中有两个关于“视图”的概念：")]),_._v(" "),v("ul",[v("li",[_._v("一个是"),v("code",[_._v("view")]),_._v("。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。 创建视图的语法是"),v("code",[_._v("create view…")]),_._v("，而它的查询方法与表一样。")]),_._v(" "),v("li",[_._v("另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即"),v("code",[_._v("consistent read view")]),_._v("，用于支持 RC（Read Committed，提交读）和 RR（Repeatable Read，可重复读）隔离级别的实现")])]),_._v(" "),v("h2",{attrs:{id:"快照在-mvcc-里是怎么工作的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#快照在-mvcc-里是怎么工作的"}},[_._v("#")]),_._v(" 快照在 MVCC 里是怎么工作的")]),_._v(" "),v("p",[_._v("“快照”是基于整个数据库的，创建的速度很快但是它并不是通过拷贝整个数据库来实现的")]),_._v(" "),v("h3",{attrs:{id:"快照-的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#快照-的实现"}},[_._v("#")]),_._v(" “快照”的实现")]),_._v(" "),v("h4",{attrs:{id:"前缀知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前缀知识"}},[_._v("#")]),_._v(" 前缀知识")]),_._v(" "),v("ol",[v("li",[_._v("InnoDB 中的每个事务都有唯一的一个事务 ID（"),v("code",[_._v("transaction id")]),_._v("），是事务在开始的时候向 InnoDB 的事务系统申请的，并且事务 ID 严格按照申请时间（启动时间）递增")]),_._v(" "),v("li",[_._v("数据库表里的每行数据也有多个版本，每当事务更新某一行记录时，就会产生一个新的数据版本，这个新版本的事务 ID（"),v("code",[_._v("row trx_id")]),_._v("）为该事务的"),v("code",[_._v("transaction id")]),_._v("，并且旧版本也会保留，并且这个过程中会生成相应的 undolog，方便查看之前的数据版本")])]),_._v(" "),v("h4",{attrs:{id:"具体实现-以-可重复读-隔离级别为例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#具体实现-以-可重复读-隔离级别为例"}},[_._v("#")]),_._v(" 具体实现（以“可重复读”隔离级别为例）")]),_._v(" "),v("p",[_._v("在实现上，InnoDB 为每个事务构建了一个数组，用来存放在事务启动的瞬间，当前正在活跃的事务 ID，活跃是指已经启动、但还未提交的事务。将这个数组中最小的事务 ID 设为低水位，当前系统已经创建的最大事务 ID +1 设为高水位（那么高水位 - 1 = 当前事务 ID）")]),_._v(" "),v("blockquote",[v("p",[_._v("这个视图数组和高水位一起组成了当前事务的一致性视图（read-view）")])]),_._v(" "),v("p",[_._v("通过视图数组，可以判断数据的可见性规则如下（基于比较数据版本的"),v("code",[_._v("row trx_id")]),_._v("与当前事务 ID 的大小）")]),_._v(" "),v("ol",[v("li",[_._v("如果"),v("code",[_._v("row trx_id < 低水位")]),_._v("，那么表示这个版本是由已提交的事务生成的，是可见的")]),_._v(" "),v("li",[_._v("如果"),v("code",[_._v("row trx_id >= 低水位 && row trx_id < 高水位")]),_._v(" "),v("ol",[v("li",[_._v("如果"),v("code",[_._v("row trx_id == 高水位 - 1")]),_._v("，那么表示这个版本是由当前事务生成的，是"),v("strong",[_._v("可见")]),_._v("的")]),_._v(" "),v("li",[_._v("如果"),v("code",[_._v("row trx_id")]),_._v("不在数组中，那么表示这个版本是由已提交的事务生成的，是"),v("strong",[_._v("可见")]),_._v("的")]),_._v(" "),v("li",[_._v("如果"),v("code",[_._v("row trx_id")]),_._v("在数组中，那么表示这个版本是由还未提交的事务生成的，是"),v("strong",[_._v("不可见")]),_._v("的")])])]),_._v(" "),v("li",[_._v("如果"),v("code",[_._v("row trx_id >= 高水位")]),_._v("，那么表示这个版本是由将来启动的事务生成的，是"),v("strong",[_._v("不可见")]),_._v("的")])]),_._v(" "),v("p",[_._v("这样即使事务从启动到提交的过程中，数据有发生改变，但是无论事务在什么时候查询，查到某行记录的结果都是不变的，这就叫做"),v("strong",[_._v("一致性读")]),_._v("\nInnoDB 就是利用了“所有数据都有多个版本”的特性，让当前事务就可以通过这个规则和"),v("code",[_._v("undolog")]),_._v("日志，拿到最近的“"),v("strong",[_._v("可见")]),_._v("”数据版本，实现“秒级创建快照”的能力")]),_._v(" "),v("h2",{attrs:{id:"事务在更新时候的逻辑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务在更新时候的逻辑"}},[_._v("#")]),_._v(" 事务在更新时候的逻辑")]),_._v(" "),v("blockquote",[v("p",[_._v("重点：在更新的时候，都是先读后写的，读的是该记录当前的值，称为“当前读”")])]),_._v(" "),v("p",[_._v("如果更新数据的时候不采用当前读，那么其他事务在该数据上进行的更新就会丢失，这是不行的\n除了"),v("code",[_._v("update")]),_._v("语句，如果"),v("code",[_._v("select")]),_._v("语句加了锁（读锁、写锁），那么也是当前读\n可重复读的核心：一致性读，事务更新数据的时候只能使用当前读，如果要更新的记录的行锁被其他事务所占用，那么需要等到其他事务提交之后，释放锁后才能够继续更新，在这之前会被阻塞等待")]),_._v(" "),v("h2",{attrs:{id:"可重复读与提交读在逻辑上的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可重复读与提交读在逻辑上的区别"}},[_._v("#")]),_._v(" 可重复读与提交读在逻辑上的区别")]),_._v(" "),v("ul",[v("li",[_._v("在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图")]),_._v(" "),v("li",[_._v("在提交读隔离级别下，每一个语句执行前都会重新算出一个新的视图")])]),_._v(" "),v("p",[v("strong",[_._v("例子")]),_._v(" "),v("code",[_._v("insert into t(id, k) values(1,1),(2,2);")]),_._v("，并且数据库的参数"),v("code",[_._v("autocommit")]),_._v("默认为 1")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("事务 A")]),_._v(" "),v("th",[_._v("事务 B")]),_._v(" "),v("th",[_._v("事务 C")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("start transaction with consistent snapshot;")])]),_._v(" "),v("td"),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[v("code",[_._v("start transaction with consistent snapshot;")])]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td"),_._v(" "),v("td",[v("code",[_._v("update t set k = k + 1 where id = 1;")])])]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[v("code",[_._v("update t set k = k + 1 where id = 1; select k from t where id = 1;")])]),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td",[v("code",[_._v("select k from t where id = 1; commit;")])]),_._v(" "),v("td"),_._v(" "),v("td")]),_._v(" "),v("tr",[v("td"),_._v(" "),v("td",[v("code",[_._v("commit;")])]),_._v(" "),v("td")])])]),_._v(" "),v("ul",[v("li",[_._v("可重复读隔离级别下，事务 A 查询到的 k = 1，事务 B 查到的 k = 3")]),_._v(" "),v("li",[_._v("提交读隔离级别下，事务 A 查询到的 k = 2，事务 B 查到的 k = 3")])])])}),[],!1,null,null,null);t.default=o.exports}}]);